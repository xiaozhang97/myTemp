# let和const命令
## 1.let 语法
> 声明的变量，**只在let命令所在的代码块内有效。**
~~~JavaScript
{}、for循环、函数
~~~

### 不存在变量提升
|区别   |var            |let
|:---   |:---	         |:---
|变量   |有变量提升       |无变量提升
|值     |为undefined     |报错

### 暂时性死区
> 在代码块内，**在let命令声明变量之前，变量都不可用。**即“暂时性死区”（temporal dead zone，简称 TDZ）。必须先声明后使用。

> 目的：*为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。*

### 不允许重复声明
> 不能在函数内部重新声明参数。

## 2.块级作用域
|区别    |var              |let
|:---    |:---            |:---
|作用域  |全局作用域、函数作用域 |块级作用域
|结果    |内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量 |外层代码块不受内层代码块的影响；允许块级作用域的任意嵌套；内层作用域可以定义外层作用域的同名变量

### 块级作用域与函数声明
> ES5 函数只能在**顶层作用域和函数作用域**之中声明，不能在块级作用域声明。

> ES6 允许在块级作用域之中声明函数。块级作用域之中，函数声明语句的行为类似于let，**在块级作用域之外不可引用。**

> 因为浏览器运行环境差异较大，避免在块级作用域内声明函数。**尽量把函数声明语句写成函数表达式。**

## 3.const 命令
> 声明：常量，值不能改变，不可重复声明；

> 声明的常量也是**不提升，**同样存在**暂时性死区，**只能在声明的位置后面使用。

### const 本质
|区别   |简单数据类型            |复合数据类型
|:---   |:---	         |:---
|值     |（数值、字符串、布尔值）     |（主要是对象和数组）
|变量   |值就保存在变量指向的那个内存地址，因此等同于常量。          |变量指向的内存地址，保存的只是一个指向实际数据的指针，只能保证这个指针是固定的，不能保证它指向的数据结构是否可变。

~~~JavaScript
	//foo储存的是一个地址，指向一个对象。
	const foo = {};

	// 为 foo 添加一个属性，可以成功
	foo.prop = 123;
	foo.prop // 123

	// 将 foo 指向另一个对象，就会报错
	foo = {}; // TypeError: "foo" is read-only

	地址不可变，对象本身可变，可以为对象添加新属性。
~~~

~~~JavaScript
	const a = [];
	a.push('Hello'); // 可执行
	a.length = 0;    // 可执行
	a = ['b'];    // 报错
~~~

## 4.顶层对象的属性 
|顶层对象
|:---
|浏览器--->window对象
|Node --->global对象
|ES5  --->顶层对象的属性 = 全局变量
|var、function命令声明的全局变量，依旧是顶层对象的属性
|let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性

## 5.globalThis 对象
> ES2020 引入globalThis作为顶层对象。任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。


# 变量的解构赋值
## 1.数组的解构赋值
### 基本用法
~~~JavaScript
	let [a, b, c] = [1, 2, 3];

	let [foo, [[bar], baz]] = [1, [[2], 3]];
	foo // 1
	bar // 2
	baz // 3

	let [ , , third] = ["foo", "bar", "baz"];
	third // "baz"

	let [x, , y] = [1, 2, 3];
	x // 1
	y // 3

	let [head, ...tail] = [1, 2, 3, 4];
	head // 1
	tail // [2, 3, 4]

	let [x, y, ...z] = ['a'];
	x // "a"
	y // undefined
	z // []
~~~

> 解构不成功，变量 = undefined
~~~JavaScript
	let [foo] = [];
	let [bar, foo] = [1];
~~~
> 不完全解构，左右两边个数不完全匹配
~~~JavaScript
	let [x, y] = [1, 2, 3];
	x // 1
	y // 2

	let [a, [b], d] = [1, [2, 3], 4];
	a // 1
	b // 2
	d // 4
~~~
> 左右两边类型不匹配（报错）
~~~JavaScript
	// 报错
	let [foo] = 1;
	let [foo] = false;
	let [foo] = NaN;
	let [foo] = undefined;
	let [foo] = null;
	let [foo] = {};
~~~
> Set 解构赋值
~~~JavaScript
	let [x, y, z] = new Set(['a', 'b', 'c']);
	x // "a"
~~~

### 默认值
~~~JavaScript
	let [foo = true] = [];
	foo // true
	
	let [x, y = 'b'] = ['a']; // x='a', y='b'
	let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
~~~

## 2.对象的解构赋值
|区别    |数组解构赋值      |对象解构赋值
|:---    |:---            |:---
|作用域  |数组的元素是按次序排列的，变量的取值由它的位置决定 |而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

~~~JavaScript
	let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
	foo // "aaa"  foo -->"aaa" 
	bar // "bbb"  bar -->"bbb"

	let { baz } = { foo: 'aaa', bar: 'bbb' };
	baz // undefined  baz-->没有值对应，解构失败
~~~
